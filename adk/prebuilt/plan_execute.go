/*
 * Copyright 2025 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package prebuilt

import (
	"context"
	"errors"
	"fmt"
	"io"
	"runtime/debug"
	"strings"

	"github.com/bytedance/sonic"

	"github.com/cloudwego/eino/adk"
	"github.com/cloudwego/eino/components/model"
	"github.com/cloudwego/eino/components/prompt"
	"github.com/cloudwego/eino/internal/safe"
	"github.com/cloudwego/eino/schema"
)

// Plan represents a structured output format with a list of steps to be executed.
// This struct is used for JSON serialization/deserialization of the plan output
// generated by the model.
//
// JSON Schema:
//
//	{
//	  "type": "object",
//	  "properties": {
//	    "steps": {
//	      "type": "array",
//	      "items": {
//	        "type": "string"
//	      },
//	      "description": "Ordered list of actions to be taken. Each step should be clear, actionable, and arranged in a logical sequence."
//	    }
//	  },
//	  "required": ["steps"]
//	}
type Plan struct {
	// Steps contains the ordered list of actions to be taken.
	// Each step should be clear, actionable, and arranged in a logical sequence.
	Steps []string `json:"steps"`
}

// Response represents the final response to the user.
// This struct is used for JSON serialization/deserialization of the final response
// generated by the model.
type Response struct {
	// Response is the complete response to provide to the user.
	// This field is required.
	Response string `json:"response"`
}

var (
	// PlanToolInfo defines the schema for the Plan tool that can be used with ToolCallingChatModel.
	// This schema instructs the model to generate a structured plan with ordered steps.
	PlanToolInfo = schema.ToolInfo{
		Name: "Plan",
		Desc: "Plan with a list of steps to execute in order. Each step should be clear, actionable, and arranged in a logical sequence. The output will be used to guide the execution process.",
		ParamsOneOf: schema.NewParamsOneOfByParams(
			map[string]*schema.ParameterInfo{
				"steps": {
					Type:     schema.Array,
					ElemInfo: &schema.ParameterInfo{Type: schema.String},
					Desc:     "different steps to follow, should be in sorted order",
					Required: true,
				},
			},
		),
	}

	// RespondToolInfo defines the schema for the response tool that can be used with ToolCallingChatModel.
	// This schema instructs the model to generate a direct response to the user.
	RespondToolInfo = schema.ToolInfo{
		Name: "Respond",
		Desc: "Generate a direct response to the user. Use this tool when you have all the information needed to provide a final answer.",
		ParamsOneOf: schema.NewParamsOneOfByParams(
			map[string]*schema.ParameterInfo{
				"response": {
					Type:     schema.String,
					Desc:     "The complete response to provide to the user",
					Required: true,
				},
			},
		),
	}

	ExecutorUserPrompt = prompt.FromMessages(schema.FString, schema.UserMessage(
		"Given the following plan:\n{plan}\nYour task is to execute the first step, which is: {task}."))

	ReplannerUserPrompt = prompt.FromMessages(schema.FString, schema.UserMessage(
		`You are going to review the progress toward an objective. Analyze the current state and determine the optimal next action.

## OBJECTIVE
{input}

## ORIGINAL PLAN
{plan}

## COMPLETED STEPS & RESULTS
{executed_results}

## YOUR TASK
Based on the progress above, you MUST choose exactly ONE action:

### Option 1: COMPLETE (if objective is fully achieved)
Call '{respond_tool}' with:
- A comprehensive final answer
- Clear conclusion summarizing how the objective was met
- Key insights from the execution process

### Option 2: CONTINUE (if more work is needed)
Call '{plan_tool}' with a revised plan that:
- Contains ONLY remaining steps (exclude completed ones)
- Incorporates lessons learned from executed steps
- Addresses any gaps or issues discovered
- Maintains logical step sequence

## PLANNING GUIDELINES
- Each step must be specific and actionable
- Include all necessary context and parameters
- Eliminate redundant or unnecessary steps
- Adapt strategy based on new information
- Ensure steps directly contribute to the objective

## DECISION CRITERIA
- Has the original objective been completely satisfied?
- Are there any remaining requirements or sub-goals?
- Do the results suggest a need for strategy adjustment?
- What specific actions are still required?`))
)

const (
	PlanExecuteUserInputSessionKey = "UserInput"

	// PlannerInstruction is the system instruction for the planner.
	// It provides context and guidance to the planner on how to generate the Plan.
	PlannerInstruction = `You are an expert planning agent. Given an objective, create a step-by-step plan to achieve the objective. Each step must be:
- Specific and actionable
- Self-contained with all necessary context
- Executable independently by an agent
- Logically ordered
- Contributing directly to the objective

Avoid redundant steps. Ensure the final step produces the complete answer. Include relevant constraints, parameters, and success criteria in each step.`

	// PlanSessionKey is the session key for the plan.
	PlanSessionKey = "Plan"

	// ExecuteResultSessionKey is the session key for the execute result.
	ExecuteResultSessionKey = "ExecuteResult"

	// ExecuteResultsSessionKey is the session key for the execute results.
	ExecuteResultsSessionKey = "ExecuteResults"
)

// PlannerConfig provides configuration options for creating a planner agent.
// There are two ways to configure the planner to generate structured Plan output:
//  1. Use ChatModelWithFormattedOutput: A model already configured to output in the Plan format
//  2. Use ToolCallingChatModel + ToolInfo: A model that will be configured to use tool calling
//     to generate the Plan structure
type PlannerConfig struct {
	// ChatModelWithFormattedOutput is a model pre-configured to output in the Plan format.
	// This can be created by configuring a model to output structured data directly.
	// Can refer to https://github.com/cloudwego/eino-ext/blob/main/components/model/openai/examples/structured/structured.go.
	ChatModelWithFormattedOutput model.BaseChatModel

	// ToolCallingChatModel is a model that supports tool calling capabilities.
	// When provided along with ToolInfo, the model will be configured to use tool calling
	// to generate the Plan structure.
	ToolCallingChatModel model.ToolCallingChatModel
	// ToolInfo defines the schema for the Plan structure when using tool calling.
	// If not provided, PlanToolInfo will be used as the default.
	ToolInfo *schema.ToolInfo

	// Instruction is the system instruction for the planner.
	// It provides context and guidance to the planner on how to generate the Plan.
	// If not provided, PlannerInstruction will be used as the default.
	Instruction string
}

type planner struct {
	toolCall  bool
	chatModel model.BaseChatModel
	sysMsg    *schema.Message
}

func (p *planner) Name(_ context.Context) string {
	return "Planner"
}

func (p *planner) Description(_ context.Context) string {
	return "a planner agent"
}

func argToContent(msg adk.Message) (adk.Message, error) {
	if len(msg.ToolCalls) == 0 {
		return nil, schema.ErrNoValue
	}

	return schema.AssistantMessage(msg.ToolCalls[0].Function.Arguments, nil), nil
}

func (p *planner) Run(ctx context.Context, input *adk.AgentInput,
	_ ...adk.AgentRunOption) *adk.AsyncIterator[*adk.AgentEvent] {

	iterator, generator := adk.NewAsyncIteratorPair[*adk.AgentEvent]()

	adk.SetSessionValue(ctx, PlanExecuteUserInputSessionKey, input.Messages)

	go func() {
		defer func() {
			panicErr := recover()
			if panicErr != nil {
				e := safe.NewPanicErr(panicErr, debug.Stack())
				generator.Send(&adk.AgentEvent{Err: e})
			}

			generator.Close()
		}()

		msgs := make([]*schema.Message, 0, len(input.Messages)+1)
		msgs = append(msgs, p.sysMsg)
		msgs = append(msgs, input.Messages...)
		var modelCallOptions []model.Option
		if p.toolCall {
			modelCallOptions = append(modelCallOptions, model.WithToolChoice(schema.ToolChoiceForced))
		}

		var msg adk.Message
		if input.EnableStreaming {
			s, err := p.chatModel.Stream(ctx, msgs, modelCallOptions...)
			if err != nil {
				generator.Send(&adk.AgentEvent{Err: err})
				return
			}

			ss := s.Copy(2)
			var sOutput *schema.StreamReader[*schema.Message]
			if p.toolCall {
				sOutput = schema.StreamReaderWithConvert(ss[0], argToContent)
			} else {
				sOutput = ss[0]
			}

			event := adk.EventFromMessage(nil, sOutput, schema.Assistant, "")
			generator.Send(event)

			msg, err = schema.ConcatMessageStream(ss[1])
			if err != nil {
				generator.Send(&adk.AgentEvent{Err: err})
				return
			}

			if p.toolCall && len(msg.ToolCalls) == 0 {
				generator.Send(&adk.AgentEvent{Err: errors.New("no tool call")})
				return
			}
		} else {
			var err error
			msg, err = p.chatModel.Generate(ctx, msgs, modelCallOptions...)
			if err != nil {
				generator.Send(&adk.AgentEvent{Err: err})
				return
			}

			var output adk.Message
			if p.toolCall {
				if len(msg.ToolCalls) == 0 {
					generator.Send(&adk.AgentEvent{Err: errors.New("no tool call")})
					return
				}
				output = schema.AssistantMessage(msg.ToolCalls[0].Function.Arguments, nil)
			} else {
				output = msg
			}

			event := adk.EventFromMessage(output, nil, schema.Assistant, "")
			generator.Send(event)
		}

		var plan Plan
		var planJSON string
		if p.toolCall {
			planJSON = msg.ToolCalls[0].Function.Arguments
		} else {
			planJSON = msg.Content
		}
		err := sonic.UnmarshalString(planJSON, &plan)
		if err != nil {
			err = fmt.Errorf("unmarshal plan error: %w", err)
			generator.Send(&adk.AgentEvent{Err: err})
			return
		}

		adk.SetSessionValue(ctx, PlanSessionKey, &plan)
	}()

	return iterator
}

// NewPlanner creates a new planner agent based on the provided configuration.
// The planner agent uses either ChatModelWithFormattedOutput or ToolCallingChatModel+ToolInfo
// to generate structured Plan output.
//
// If ChatModelWithFormattedOutput is provided, it will be used directly.
// If ToolCallingChatModel is provided, it will be configured with ToolInfo (or PlanToolInfo by default)
// to generate structured Plan output.
func NewPlanner(_ context.Context, cfg *PlannerConfig) (adk.Agent, error) {
	instruction := cfg.Instruction
	if instruction == "" {
		instruction = PlannerInstruction
	}
	sysMsg := schema.SystemMessage(instruction)

	var chatModel model.BaseChatModel
	var toolCall bool
	if cfg.ChatModelWithFormattedOutput != nil {
		chatModel = cfg.ChatModelWithFormattedOutput
	} else {
		toolCall = true
		toolInfo := cfg.ToolInfo
		if toolInfo == nil {
			toolInfo = &PlanToolInfo
		}

		var err error
		chatModel, err = cfg.ToolCallingChatModel.WithTools([]*schema.ToolInfo{toolInfo})
		if err != nil {
			return nil, err
		}
	}

	return &planner{
		toolCall:  toolCall,
		chatModel: chatModel,
		sysMsg:    sysMsg,
	}, nil
}

type ExecutorConfig struct {
	Instruction string
	Model       model.ToolCallingChatModel
	ToolsConfig adk.ToolsConfig
	MaxStep     int
}

type ExecuteResult struct {
	Task   string
	Result string
}

func formatPlan(p *Plan) string {
	var formattedPlan strings.Builder
	for i, step := range p.Steps {
		formattedPlan.WriteString(fmt.Sprintf("%d. %s\n", i+1, step))
	}

	return formattedPlan.String()
}

// NewExecutor creates a new executor agent.
func NewExecutor(ctx context.Context, cfg *ExecutorConfig) (adk.Agent, error) {
	genInput := func(ctx context.Context, instruction string, _ *adk.AgentInput) ([]adk.Message, error) {
		msgs := make([]adk.Message, 0, 2)

		if instruction != "" {
			sp := schema.SystemMessage(instruction)
			msgs = append(msgs, sp)
		}

		plan, ok := adk.GetSessionValue(ctx, PlanSessionKey)
		if !ok {
			panic("impossible: plan not found")
		}
		plan_ := plan.(*Plan)
		task := plan_.Steps[0]

		userMsgs, err := ExecutorUserPrompt.Format(ctx, map[string]any{
			"plan": formatPlan(plan_),
			"task": task,
		})
		if err != nil {
			return nil, err
		}

		msgs = append(msgs, userMsgs...)

		return msgs, nil
	}

	agent, err := adk.NewChatModelAgent(ctx, &adk.ChatModelAgentConfig{
		Name:          "Executor",
		Description:   "an executor agent",
		Instruction:   cfg.Instruction,
		Model:         cfg.Model,
		ToolsConfig:   cfg.ToolsConfig,
		GenModelInput: genInput,
		MaxStep:       cfg.MaxStep,
		OutputKey:     ExecuteResultSessionKey,
	})
	if err != nil {
		return nil, err
	}

	return agent, nil
}

type replanner struct {
	chatModel   model.ToolCallingChatModel
	instruction string
	planTool    *schema.ToolInfo
	respondTool *schema.ToolInfo
}

type ReplannerConfig struct {
	// Instruction is the system instruction for the replanner.
	// It provides context and guidance to the replanner on how to update the plan or respond to the user.
	Instruction string

	// ChatModel is the model that supports tool calling capabilities.
	// It will be configured with PlanTool and RespondTool to generate updated plans or responses.
	ChatModel model.ToolCallingChatModel

	// PlanTool defines the schema for the Plan tool that can be used with ToolCallingChatModel.
	// If not provided, the default PlanToolInfo will be used.
	PlanTool *schema.ToolInfo

	// RespondTool defines the schema for the response tool that can be used with ToolCallingChatModel.
	// If not provided, the default RespondToolInfo will be used.
	RespondTool *schema.ToolInfo
}

func formatInput(input []adk.Message) string {
	var sb strings.Builder
	for _, msg := range input {
		sb.WriteString(msg.Content)
		sb.WriteString("\n")
	}

	return sb.String()
}

func formatExecutedResults(results []ExecuteResult) string {
	var sb strings.Builder
	for _, result := range results {
		sb.WriteString(fmt.Sprintf("Task: %s\nResult: %s\n\n", result.Task, result.Result))
	}

	return sb.String()
}

func (r *replanner) Name(_ context.Context) string {
	return "Replanner"
}

func (r *replanner) Description(_ context.Context) string {
	return "a replanner agent"
}

func (r *replanner) genInput(ctx context.Context) ([]adk.Message, error) {
	msgs := make([]adk.Message, 0, 2)

	if r.instruction != "" {
		sp := schema.SystemMessage(r.instruction)
		msgs = append(msgs, sp)
	}

	executeResult, ok := adk.GetSessionValue(ctx, ExecuteResultSessionKey)
	if !ok {
		panic("impossible: execute result not found")
	}
	executeResult_ := executeResult.(string)

	plan, ok := adk.GetSessionValue(ctx, PlanSessionKey)
	if !ok {
		panic("impossible: plan not found")
	}
	plan_ := plan.(*Plan)
	task := plan_.Steps[0]

	var executeResults_ []ExecuteResult
	executeResults, ok := adk.GetSessionValue(ctx, ExecuteResultsSessionKey)
	if ok {
		executeResults_ = executeResults.([]ExecuteResult)
	}

	executeResults_ = append(executeResults_, ExecuteResult{
		Task:   task,
		Result: executeResult_,
	})
	adk.SetSessionValue(ctx, ExecuteResultsSessionKey, executeResults_)

	userInput, ok := adk.GetSessionValue(ctx, PlanExecuteUserInputSessionKey)
	if !ok {
		panic("impossible: user input not found")
	}
	userInput_ := userInput.([]adk.Message)

	userMsgs, err := ReplannerUserPrompt.Format(ctx, map[string]any{
		"plan":             formatPlan(plan_),
		"input":            formatInput(userInput_),
		"executed_results": formatExecutedResults(executeResults_),
		"plan_tool":        r.planTool.Name,
		"respond_tool":     r.respondTool.Name,
	})
	if err != nil {
		return nil, err
	}

	msgs = append(msgs, userMsgs...)

	return msgs, nil
}

func (r *replanner) Run(ctx context.Context, input *adk.AgentInput, _ ...adk.AgentRunOption) *adk.AsyncIterator[*adk.AgentEvent] {
	iterator, generator := adk.NewAsyncIteratorPair[*adk.AgentEvent]()
	msgs, err := r.genInput(ctx)
	if err != nil {
		generator.Send(&adk.AgentEvent{Err: err})
		generator.Close()
		return iterator
	}

	go func() {
		defer func() {
			panicErr := recover()
			if panicErr != nil {
				e := safe.NewPanicErr(panicErr, debug.Stack())
				generator.Send(&adk.AgentEvent{Err: e})
			}

			generator.Close()
		}()

		callOpt := model.WithToolChoice(schema.ToolChoiceForced)

		var planMsg adk.Message
		if input.EnableStreaming {
			var s adk.MessageStream
			s, err = r.chatModel.Stream(ctx, msgs, callOpt)
			if err != nil {
				generator.Send(&adk.AgentEvent{Err: err})
				return
			}

			ss := s.Copy(2)
			sOutput := schema.StreamReaderWithConvert(ss[0], argToContent)
			event := adk.EventFromMessage(nil, sOutput, schema.Assistant, "")
			generator.Send(event)

			var chunks []adk.Message
			s = ss[1]
			var isResponse bool
			for {
				chunk, err_ := s.Recv()
				if err_ != nil {
					if err_ == io.EOF {
						break
					}

					generator.Send(&adk.AgentEvent{Err: err_})
					return
				}

				if len(chunk.ToolCalls) > 0 && chunk.ToolCalls[0].Function.Name == r.respondTool.Name {
					isResponse = true
					break
				}

				chunks = append(chunks, chunk)
			}
			s.Close()

			if isResponse {
				action := adk.NewExitAction()
				generator.Send(&adk.AgentEvent{Action: action})
				return
			}

			planMsg, err = schema.ConcatMessages(chunks)
			if err != nil {
				generator.Send(&adk.AgentEvent{Err: err})
				return
			}

			if len(planMsg.ToolCalls) == 0 {
				generator.Send(&adk.AgentEvent{Err: errors.New("no tool call")})
				return
			}
		} else {
			var msg adk.Message
			msg, err = r.chatModel.Generate(ctx, msgs, callOpt)
			if err != nil {
				generator.Send(&adk.AgentEvent{Err: err})
				return
			}

			if len(msg.ToolCalls) > 0 {
				output := schema.AssistantMessage(msg.ToolCalls[0].Function.Arguments, nil)
				event := adk.EventFromMessage(output, nil, schema.Assistant, "")
				generator.Send(event)

				if len(msg.ToolCalls) > 0 && msg.ToolCalls[0].Function.Name == r.respondTool.Name {
					action := adk.NewExitAction()
					generator.Send(&adk.AgentEvent{Action: action})
					return
				}

				planMsg = msg
			} else {
				generator.Send(&adk.AgentEvent{Err: errors.New("no tool call")})
				return
			}
		}

		// handle plan tool call
		if planMsg.ToolCalls[0].Function.Name != r.planTool.Name {
			errMsg := fmt.Sprintf("unexpected tool call: %s", planMsg.ToolCalls[0].Function.Name)
			generator.Send(&adk.AgentEvent{Err: errors.New(errMsg)})
			return
		}

		var plan Plan
		err = sonic.UnmarshalString(planMsg.ToolCalls[0].Function.Arguments, &plan)
		if err != nil {
			err = fmt.Errorf("unmarshal plan error: %w", err)
			generator.Send(&adk.AgentEvent{Err: err})
			return
		}

		adk.SetSessionValue(ctx, PlanSessionKey, &plan)
	}()

	return iterator
}

func NewReplanner(_ context.Context, cfg *ReplannerConfig) (adk.Agent, error) {
	planTool := cfg.PlanTool
	if planTool == nil {
		planTool = &PlanToolInfo
	}

	respondTool := cfg.RespondTool
	if respondTool == nil {
		respondTool = &RespondToolInfo
	}

	chatModel, err := cfg.ChatModel.WithTools([]*schema.ToolInfo{planTool, respondTool})
	if err != nil {
		return nil, err
	}

	return &replanner{
		chatModel:   chatModel,
		instruction: cfg.Instruction,
		planTool:    planTool,
		respondTool: respondTool,
	}, nil
}

type PlanExecuteConfig struct {
	Planner   adk.Agent
	Executor  adk.Agent
	Replanner adk.Agent
}

func NewPlanExecuteAgent(ctx context.Context, cfg *PlanExecuteConfig) (adk.Agent, error) {
	loop, err := adk.NewLoopAgent(ctx, &adk.LoopAgentConfig{
		Name:          "execute_replan",
		SubAgents:     []adk.Agent{cfg.Executor, cfg.Replanner},
		MaxIterations: 10,
	})
	if err != nil {
		return nil, err
	}

	return adk.NewSequentialAgent(ctx, &adk.SequentialAgentConfig{
		Name:      "plan_execute_replan",
		SubAgents: []adk.Agent{cfg.Planner, loop},
	})
}
